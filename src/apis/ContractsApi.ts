/* tslint:disable */
/* eslint-disable */
/**
 * MetaFab API
 *  Complete MetaFab API references and guides can be found at: https://trymetafab.com
 *
 * The version of the OpenAPI document: 1.4.3
 * Contact: metafabproject@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ContractModel,
  CreateContractRequest,
  TransactionModel,
  TransferContractOwnershipRequest,
  UpgradeContractTrustedForwarderRequest,
  WriteContractRequest,
} from '../models';
import {
    ContractModelFromJSON,
    ContractModelToJSON,
    CreateContractRequestFromJSON,
    CreateContractRequestToJSON,
    TransactionModelFromJSON,
    TransactionModelToJSON,
    TransferContractOwnershipRequestFromJSON,
    TransferContractOwnershipRequestToJSON,
    UpgradeContractTrustedForwarderRequestFromJSON,
    UpgradeContractTrustedForwarderRequestToJSON,
    WriteContractRequestFromJSON,
    WriteContractRequestToJSON,
} from '../models';

export interface CreateContractOperationRequest {
    xAuthorization: string;
    createContractRequest: CreateContractRequest;
}

export interface GetContractsRequest {
    xGameKey: string;
}

export interface ReadContractRequest {
    contractId: string;
    func: string;
    args?: string;
}

export interface TransferContractOwnershipOperationRequest {
    contractId: string;
    xAuthorization: string;
    xPassword: string;
    transferContractOwnershipRequest: TransferContractOwnershipRequest;
}

export interface UpgradeContractTrustedForwarderOperationRequest {
    contractId: string;
    xAuthorization: string;
    xPassword: string;
    upgradeContractTrustedForwarderRequest: UpgradeContractTrustedForwarderRequest;
}

export interface WriteContractOperationRequest {
    contractId: string;
    xAuthorization: string;
    xPassword: string;
    writeContractRequest: WriteContractRequest;
}

/**
 * 
 */
export class ContractsApi extends runtime.BaseAPI {

    /**
     * Create a MetaFab custom contract entry from an existing contract address and contract abi. This allows the game and players belonging to the authenticated game to interact with the contract\'s read and write functions through MetaFab\'s read and write contract endpoints.
     * Create custom contract
     */
    async createContractRaw(requestParameters: CreateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContractModel>> {
        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling createContract.');
        }

        if (requestParameters.createContractRequest === null || requestParameters.createContractRequest === undefined) {
            throw new runtime.RequiredError('createContractRequest','Required parameter requestParameters.createContractRequest was null or undefined when calling createContract.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        const response = await this.request({
            path: `/v1/contracts`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateContractRequestToJSON(requestParameters.createContractRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContractModelFromJSON(jsonValue));
    }

    /**
     * Create a MetaFab custom contract entry from an existing contract address and contract abi. This allows the game and players belonging to the authenticated game to interact with the contract\'s read and write functions through MetaFab\'s read and write contract endpoints.
     * Create custom contract
     */
    async createContract(requestParameters: CreateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContractModel> {
        const response = await this.createContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of active contracts deployed by the game associated with the provided `X-Game-Key`.
     * Get contracts
     */
    async getContractsRaw(requestParameters: GetContractsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ContractModel>>> {
        if (requestParameters.xGameKey === null || requestParameters.xGameKey === undefined) {
            throw new runtime.RequiredError('xGameKey','Required parameter requestParameters.xGameKey was null or undefined when calling getContracts.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xGameKey !== undefined && requestParameters.xGameKey !== null) {
            headerParameters['X-Game-Key'] = String(requestParameters.xGameKey);
        }

        const response = await this.request({
            path: `/v1/contracts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ContractModelFromJSON));
    }

    /**
     * Returns an array of active contracts deployed by the game associated with the provided `X-Game-Key`.
     * Get contracts
     */
    async getContracts(requestParameters: GetContractsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ContractModel>> {
        const response = await this.getContractsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Oftentimes you\'ll want to query and retrieve some data from a contract. This is incredibly easy to do for any contract deployed through MetaFab.  Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
     * Read contract data
     */
    async readContractRaw(requestParameters: ReadContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
            throw new runtime.RequiredError('contractId','Required parameter requestParameters.contractId was null or undefined when calling readContract.');
        }

        if (requestParameters.func === null || requestParameters.func === undefined) {
            throw new runtime.RequiredError('func','Required parameter requestParameters.func was null or undefined when calling readContract.');
        }

        const queryParameters: any = {};

        if (requestParameters.func !== undefined) {
            queryParameters['func'] = requestParameters.func;
        }

        if (requestParameters.args !== undefined) {
            queryParameters['args'] = requestParameters.args;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{contractId}/reads`.replace(`{${"contractId"}}`, encodeURIComponent(String(requestParameters.contractId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Oftentimes you\'ll want to query and retrieve some data from a contract. This is incredibly easy to do for any contract deployed through MetaFab.  Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
     * Read contract data
     */
    async readContract(requestParameters: ReadContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.readContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transfer ownership and control of a MetaFab deployed smart contract to another wallet you control. Transferring control does not disrupt your usage of MetaFab APIs and can be done so without causing any service outages for your game. The new owner wallet will have full control over any relevant item collections and marketplace related pages this contract may be associated with, such as for MetaFab item or NFT contracts.  Your game\'s custodial wallet will retain a `MANAGER_ROLE` on your contracts, allowing you to still use MetaFab APIs without issue while you retain full contract ownership and the contract\'s administrator role. If ever you want eject from using the MetaFab APIs but still retain your deployed smart contracts, you can revoke the `MANAGER_ROLE` from your game\'s custodial wallet address for your contract. We do not lock you into our systems.  Please be certain that the wallet address you transfer ownership to is one you control. Once ownership and admin permissions are transferred, your game\'s custodial wallet no longer has permission to reassign ownership or administrative priveleges for your contract.
     * Transfer contract ownership
     */
    async transferContractOwnershipRaw(requestParameters: TransferContractOwnershipOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
            throw new runtime.RequiredError('contractId','Required parameter requestParameters.contractId was null or undefined when calling transferContractOwnership.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling transferContractOwnership.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling transferContractOwnership.');
        }

        if (requestParameters.transferContractOwnershipRequest === null || requestParameters.transferContractOwnershipRequest === undefined) {
            throw new runtime.RequiredError('transferContractOwnershipRequest','Required parameter requestParameters.transferContractOwnershipRequest was null or undefined when calling transferContractOwnership.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/contracts/{contractId}/owners`.replace(`{${"contractId"}}`, encodeURIComponent(String(requestParameters.contractId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransferContractOwnershipRequestToJSON(requestParameters.transferContractOwnershipRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Transfer ownership and control of a MetaFab deployed smart contract to another wallet you control. Transferring control does not disrupt your usage of MetaFab APIs and can be done so without causing any service outages for your game. The new owner wallet will have full control over any relevant item collections and marketplace related pages this contract may be associated with, such as for MetaFab item or NFT contracts.  Your game\'s custodial wallet will retain a `MANAGER_ROLE` on your contracts, allowing you to still use MetaFab APIs without issue while you retain full contract ownership and the contract\'s administrator role. If ever you want eject from using the MetaFab APIs but still retain your deployed smart contracts, you can revoke the `MANAGER_ROLE` from your game\'s custodial wallet address for your contract. We do not lock you into our systems.  Please be certain that the wallet address you transfer ownership to is one you control. Once ownership and admin permissions are transferred, your game\'s custodial wallet no longer has permission to reassign ownership or administrative priveleges for your contract.
     * Transfer contract ownership
     */
    async transferContractOwnership(requestParameters: TransferContractOwnershipOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.transferContractOwnershipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * In rare circumstances, you may need to upgrade the underlying trusted forwarder contract address attached to your game\'s contracts. Using this endpoint, you can provide a new trusted forwarder contract address to assign to any of your contracts that implement the `upgradeTrustedForwarder` function.
     * Upgrade contract trusted forwarder
     */
    async upgradeContractTrustedForwarderRaw(requestParameters: UpgradeContractTrustedForwarderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
            throw new runtime.RequiredError('contractId','Required parameter requestParameters.contractId was null or undefined when calling upgradeContractTrustedForwarder.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling upgradeContractTrustedForwarder.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling upgradeContractTrustedForwarder.');
        }

        if (requestParameters.upgradeContractTrustedForwarderRequest === null || requestParameters.upgradeContractTrustedForwarderRequest === undefined) {
            throw new runtime.RequiredError('upgradeContractTrustedForwarderRequest','Required parameter requestParameters.upgradeContractTrustedForwarderRequest was null or undefined when calling upgradeContractTrustedForwarder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/contracts/{contractId}/forwarders`.replace(`{${"contractId"}}`, encodeURIComponent(String(requestParameters.contractId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpgradeContractTrustedForwarderRequestToJSON(requestParameters.upgradeContractTrustedForwarderRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * In rare circumstances, you may need to upgrade the underlying trusted forwarder contract address attached to your game\'s contracts. Using this endpoint, you can provide a new trusted forwarder contract address to assign to any of your contracts that implement the `upgradeTrustedForwarder` function.
     * Upgrade contract trusted forwarder
     */
    async upgradeContractTrustedForwarder(requestParameters: UpgradeContractTrustedForwarderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.upgradeContractTrustedForwarderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * MetaFab\'s convenience endpoints for contract interactions may not be flexible enough depending on your use case. For these situations, you can interact with contracts and create transactions directly.  Using this endpoint, you can execute a transaction for any writeable contract method as defined in the contract\'s ABI for the MetaFab contractId provided. Both Games and Player resources have authority to use this endpoint to execute transactions against any valid MetaFab contractId.  Additionally, MetaFab will automatically attempt to perform a gasless transaction for players interacting with a contract through this endpoint. Gasless transactions by players through this endpoint will only work if the target contract was deployed through MetaFab or supports MetaFab\'s ERC2771 trusted forwarder contract.
     * Write contract data
     */
    async writeContractRaw(requestParameters: WriteContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
            throw new runtime.RequiredError('contractId','Required parameter requestParameters.contractId was null or undefined when calling writeContract.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling writeContract.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling writeContract.');
        }

        if (requestParameters.writeContractRequest === null || requestParameters.writeContractRequest === undefined) {
            throw new runtime.RequiredError('writeContractRequest','Required parameter requestParameters.writeContractRequest was null or undefined when calling writeContract.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/contracts/{contractId}/writes`.replace(`{${"contractId"}}`, encodeURIComponent(String(requestParameters.contractId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WriteContractRequestToJSON(requestParameters.writeContractRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * MetaFab\'s convenience endpoints for contract interactions may not be flexible enough depending on your use case. For these situations, you can interact with contracts and create transactions directly.  Using this endpoint, you can execute a transaction for any writeable contract method as defined in the contract\'s ABI for the MetaFab contractId provided. Both Games and Player resources have authority to use this endpoint to execute transactions against any valid MetaFab contractId.  Additionally, MetaFab will automatically attempt to perform a gasless transaction for players interacting with a contract through this endpoint. Gasless transactions by players through this endpoint will only work if the target contract was deployed through MetaFab or supports MetaFab\'s ERC2771 trusted forwarder contract.
     * Write contract data
     */
    async writeContract(requestParameters: WriteContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.writeContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
