/* tslint:disable */
/* eslint-disable */
/**
 * MetaFab API
 *  Complete MetaFab API references and guides can be found at: https://trymetafab.com
 *
 * The version of the OpenAPI document: 1.4.1
 * Contact: metafabproject@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BatchTransferCurrencyRequest,
  BurnCurrencyRequest,
  CreateCurrency200Response,
  CreateCurrencyRequest,
  GetCurrencies200ResponseInner,
  GetCurrencyFees200Response,
  GrantCurrencyRoleRequest,
  MintCurrencyRequest,
  RevokeCollectionRoleRequest,
  SetCurrencyFeesRequest,
  TransactionModel,
  TransferCurrencyRequest,
} from '../models';
import {
    BatchTransferCurrencyRequestFromJSON,
    BatchTransferCurrencyRequestToJSON,
    BurnCurrencyRequestFromJSON,
    BurnCurrencyRequestToJSON,
    CreateCurrency200ResponseFromJSON,
    CreateCurrency200ResponseToJSON,
    CreateCurrencyRequestFromJSON,
    CreateCurrencyRequestToJSON,
    GetCurrencies200ResponseInnerFromJSON,
    GetCurrencies200ResponseInnerToJSON,
    GetCurrencyFees200ResponseFromJSON,
    GetCurrencyFees200ResponseToJSON,
    GrantCurrencyRoleRequestFromJSON,
    GrantCurrencyRoleRequestToJSON,
    MintCurrencyRequestFromJSON,
    MintCurrencyRequestToJSON,
    RevokeCollectionRoleRequestFromJSON,
    RevokeCollectionRoleRequestToJSON,
    SetCurrencyFeesRequestFromJSON,
    SetCurrencyFeesRequestToJSON,
    TransactionModelFromJSON,
    TransactionModelToJSON,
    TransferCurrencyRequestFromJSON,
    TransferCurrencyRequestToJSON,
} from '../models';

export interface BatchTransferCurrencyOperationRequest {
    currencyId: string;
    xAuthorization: string;
    xPassword: string;
    batchTransferCurrencyRequest: BatchTransferCurrencyRequest;
}

export interface BurnCurrencyOperationRequest {
    currencyId: string;
    xAuthorization: string;
    xPassword: string;
    burnCurrencyRequest: BurnCurrencyRequest;
}

export interface CreateCurrencyOperationRequest {
    xAuthorization: string;
    xPassword: string;
    createCurrencyRequest: CreateCurrencyRequest;
}

export interface GetCurrenciesRequest {
    xGameKey: string;
}

export interface GetCurrencyBalanceRequest {
    currencyId: string;
    address?: string;
    walletId?: string;
}

export interface GetCurrencyFeesRequest {
    currencyId: string;
}

export interface GetCurrencyRoleRequest {
    currencyId: string;
    role: string;
    address?: string;
    walletId?: string;
}

export interface GrantCurrencyRoleOperationRequest {
    currencyId: string;
    xAuthorization: string;
    xPassword: string;
    grantCurrencyRoleRequest: GrantCurrencyRoleRequest;
}

export interface MintCurrencyOperationRequest {
    currencyId: string;
    xAuthorization: string;
    xPassword: string;
    mintCurrencyRequest: MintCurrencyRequest;
}

export interface RevokeCurrencyRoleRequest {
    currencyId: string;
    xAuthorization: string;
    xPassword: string;
    revokeCollectionRoleRequest: RevokeCollectionRoleRequest;
}

export interface SetCurrencyFeesOperationRequest {
    currencyId: string;
    xAuthorization: string;
    xPassword: string;
    setCurrencyFeesRequest: SetCurrencyFeesRequest;
}

export interface TransferCurrencyOperationRequest {
    currencyId: string;
    xAuthorization: string;
    xPassword: string;
    transferCurrencyRequest: TransferCurrencyRequest;
}

/**
 * 
 */
export class CurrenciesApi extends runtime.BaseAPI {

    /**
     * Transfers multiple amounts of currency to multiple provided wallet addresses or wallet addresses associated with the provided walletIds. You may also provide a combination of addresses and walletIds in one request, the proper receipients will be automatically determined, with `addresses` getting `amounts` order priority first.  Optional references may be included for the transfer. References are useful for identifying transfers intended to pay for items, trades, services and more.
     * Batch transfer currency
     */
    async batchTransferCurrencyRaw(requestParameters: BatchTransferCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling batchTransferCurrency.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling batchTransferCurrency.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling batchTransferCurrency.');
        }

        if (requestParameters.batchTransferCurrencyRequest === null || requestParameters.batchTransferCurrencyRequest === undefined) {
            throw new runtime.RequiredError('batchTransferCurrencyRequest','Required parameter requestParameters.batchTransferCurrencyRequest was null or undefined when calling batchTransferCurrency.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/batchTransfers`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BatchTransferCurrencyRequestToJSON(requestParameters.batchTransferCurrencyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Transfers multiple amounts of currency to multiple provided wallet addresses or wallet addresses associated with the provided walletIds. You may also provide a combination of addresses and walletIds in one request, the proper receipients will be automatically determined, with `addresses` getting `amounts` order priority first.  Optional references may be included for the transfer. References are useful for identifying transfers intended to pay for items, trades, services and more.
     * Batch transfer currency
     */
    async batchTransferCurrency(requestParameters: BatchTransferCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.batchTransferCurrencyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes (burns) the provided amount of currency from the authenticating game or players wallet. The currency amount is permanently removed from the circulating supply of the currency.
     * Burn currency
     */
    async burnCurrencyRaw(requestParameters: BurnCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling burnCurrency.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling burnCurrency.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling burnCurrency.');
        }

        if (requestParameters.burnCurrencyRequest === null || requestParameters.burnCurrencyRequest === undefined) {
            throw new runtime.RequiredError('burnCurrencyRequest','Required parameter requestParameters.burnCurrencyRequest was null or undefined when calling burnCurrency.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/burns`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BurnCurrencyRequestToJSON(requestParameters.burnCurrencyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Removes (burns) the provided amount of currency from the authenticating game or players wallet. The currency amount is permanently removed from the circulating supply of the currency.
     * Burn currency
     */
    async burnCurrency(requestParameters: BurnCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.burnCurrencyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new game currency and deploys an ERC20 token contract on behalf of the authenticating game\'s primary wallet. The deployed ERC20 contract is preconfigured to fully support bridging across blockchains, batched transfers and gasless transactions on any supported blockchain as well as full support for gasless transactions from player managed wallets.
     * Create currency
     */
    async createCurrencyRaw(requestParameters: CreateCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCurrency200Response>> {
        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling createCurrency.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling createCurrency.');
        }

        if (requestParameters.createCurrencyRequest === null || requestParameters.createCurrencyRequest === undefined) {
            throw new runtime.RequiredError('createCurrencyRequest','Required parameter requestParameters.createCurrencyRequest was null or undefined when calling createCurrency.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/currencies`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCurrencyRequestToJSON(requestParameters.createCurrencyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateCurrency200ResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new game currency and deploys an ERC20 token contract on behalf of the authenticating game\'s primary wallet. The deployed ERC20 contract is preconfigured to fully support bridging across blockchains, batched transfers and gasless transactions on any supported blockchain as well as full support for gasless transactions from player managed wallets.
     * Create currency
     */
    async createCurrency(requestParameters: CreateCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCurrency200Response> {
        const response = await this.createCurrencyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of active currencies for the game associated with the provided `X-Game-Key`.
     * Get currencies
     */
    async getCurrenciesRaw(requestParameters: GetCurrenciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GetCurrencies200ResponseInner>>> {
        if (requestParameters.xGameKey === null || requestParameters.xGameKey === undefined) {
            throw new runtime.RequiredError('xGameKey','Required parameter requestParameters.xGameKey was null or undefined when calling getCurrencies.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xGameKey !== undefined && requestParameters.xGameKey !== null) {
            headerParameters['X-Game-Key'] = String(requestParameters.xGameKey);
        }

        const response = await this.request({
            path: `/v1/currencies`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetCurrencies200ResponseInnerFromJSON));
    }

    /**
     * Returns an array of active currencies for the game associated with the provided `X-Game-Key`.
     * Get currencies
     */
    async getCurrencies(requestParameters: GetCurrenciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GetCurrencies200ResponseInner>> {
        const response = await this.getCurrenciesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the current currency balance of the provided wallet address or or the wallet address associated with the provided walletId.
     * Get currency balance
     */
    async getCurrencyBalanceRaw(requestParameters: GetCurrencyBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling getCurrencyBalance.');
        }

        const queryParameters: any = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.walletId !== undefined) {
            queryParameters['walletId'] = requestParameters.walletId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/balances`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns the current currency balance of the provided wallet address or or the wallet address associated with the provided walletId.
     * Get currency balance
     */
    async getCurrencyBalance(requestParameters: GetCurrencyBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.getCurrencyBalanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the current fee recipient address and fees of the currency for the provided currencyId. Fees are only applicable for gasless transactions performed by default by players.
     * Get currency fees
     */
    async getCurrencyFeesRaw(requestParameters: GetCurrencyFeesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCurrencyFees200Response>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling getCurrencyFees.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/fees`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCurrencyFees200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns the current fee recipient address and fees of the currency for the provided currencyId. Fees are only applicable for gasless transactions performed by default by players.
     * Get currency fees
     */
    async getCurrencyFees(requestParameters: GetCurrencyFeesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCurrencyFees200Response> {
        const response = await this.getCurrencyFeesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a boolean (true/false) representing if the provided role for this currency has been granted to the provided address or address associated with the provided walletId.
     * Get currency role
     */
    async getCurrencyRoleRaw(requestParameters: GetCurrencyRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling getCurrencyRole.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling getCurrencyRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.role !== undefined) {
            queryParameters['role'] = requestParameters.role;
        }

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.walletId !== undefined) {
            queryParameters['walletId'] = requestParameters.walletId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/roles`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns a boolean (true/false) representing if the provided role for this currency has been granted to the provided address or address associated with the provided walletId.
     * Get currency role
     */
    async getCurrencyRole(requestParameters: GetCurrencyRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.getCurrencyRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Grants the provided role for the currency to the provided address or address associated with the provided walletId. Granted roles give different types of authority on behalf of the currency for specific players, addresses, or contracts to perform different types of permissioned currency operations.
     * Grant currency role
     */
    async grantCurrencyRoleRaw(requestParameters: GrantCurrencyRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling grantCurrencyRole.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling grantCurrencyRole.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling grantCurrencyRole.');
        }

        if (requestParameters.grantCurrencyRoleRequest === null || requestParameters.grantCurrencyRoleRequest === undefined) {
            throw new runtime.RequiredError('grantCurrencyRoleRequest','Required parameter requestParameters.grantCurrencyRoleRequest was null or undefined when calling grantCurrencyRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/roles`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GrantCurrencyRoleRequestToJSON(requestParameters.grantCurrencyRoleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Grants the provided role for the currency to the provided address or address associated with the provided walletId. Granted roles give different types of authority on behalf of the currency for specific players, addresses, or contracts to perform different types of permissioned currency operations.
     * Grant currency role
     */
    async grantCurrencyRole(requestParameters: GrantCurrencyRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.grantCurrencyRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates (mints) the provided amount of currency to the provided wallet address or wallet address associated with the provided walletId.
     * Mint currency
     */
    async mintCurrencyRaw(requestParameters: MintCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling mintCurrency.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling mintCurrency.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling mintCurrency.');
        }

        if (requestParameters.mintCurrencyRequest === null || requestParameters.mintCurrencyRequest === undefined) {
            throw new runtime.RequiredError('mintCurrencyRequest','Required parameter requestParameters.mintCurrencyRequest was null or undefined when calling mintCurrency.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/mints`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MintCurrencyRequestToJSON(requestParameters.mintCurrencyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Creates (mints) the provided amount of currency to the provided wallet address or wallet address associated with the provided walletId.
     * Mint currency
     */
    async mintCurrency(requestParameters: MintCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.mintCurrencyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revokes the provided role for the currency to the provided address or address associated with the provided walletId.
     * Revoke currency role
     */
    async revokeCurrencyRoleRaw(requestParameters: RevokeCurrencyRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling revokeCurrencyRole.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling revokeCurrencyRole.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling revokeCurrencyRole.');
        }

        if (requestParameters.revokeCollectionRoleRequest === null || requestParameters.revokeCollectionRoleRequest === undefined) {
            throw new runtime.RequiredError('revokeCollectionRoleRequest','Required parameter requestParameters.revokeCollectionRoleRequest was null or undefined when calling revokeCurrencyRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/roles`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: RevokeCollectionRoleRequestToJSON(requestParameters.revokeCollectionRoleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Revokes the provided role for the currency to the provided address or address associated with the provided walletId.
     * Revoke currency role
     */
    async revokeCurrencyRole(requestParameters: RevokeCurrencyRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.revokeCurrencyRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the recipient address, basis points, fixed amount and cap amount for a currency\'s fees.
     * Set currency fees
     */
    async setCurrencyFeesRaw(requestParameters: SetCurrencyFeesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling setCurrencyFees.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling setCurrencyFees.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling setCurrencyFees.');
        }

        if (requestParameters.setCurrencyFeesRequest === null || requestParameters.setCurrencyFeesRequest === undefined) {
            throw new runtime.RequiredError('setCurrencyFeesRequest','Required parameter requestParameters.setCurrencyFeesRequest was null or undefined when calling setCurrencyFees.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/fees`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetCurrencyFeesRequestToJSON(requestParameters.setCurrencyFeesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Sets the recipient address, basis points, fixed amount and cap amount for a currency\'s fees.
     * Set currency fees
     */
    async setCurrencyFees(requestParameters: SetCurrencyFeesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.setCurrencyFeesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transfers an amount of currency to the provided wallet address or wallet address associated with the provided walletId. If you want to transfer to multiple wallets with different amounts and optional references in one API request, please see the Batch transfer currency documentation.  An optional reference may be included for the transfer. References are useful for identifying transfers intended to pay for items, trades, services and more.
     * Transfer currency
     */
    async transferCurrencyRaw(requestParameters: TransferCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.currencyId === null || requestParameters.currencyId === undefined) {
            throw new runtime.RequiredError('currencyId','Required parameter requestParameters.currencyId was null or undefined when calling transferCurrency.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling transferCurrency.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling transferCurrency.');
        }

        if (requestParameters.transferCurrencyRequest === null || requestParameters.transferCurrencyRequest === undefined) {
            throw new runtime.RequiredError('transferCurrencyRequest','Required parameter requestParameters.transferCurrencyRequest was null or undefined when calling transferCurrency.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/currencies/{currencyId}/transfers`.replace(`{${"currencyId"}}`, encodeURIComponent(String(requestParameters.currencyId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransferCurrencyRequestToJSON(requestParameters.transferCurrencyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Transfers an amount of currency to the provided wallet address or wallet address associated with the provided walletId. If you want to transfer to multiple wallets with different amounts and optional references in one API request, please see the Batch transfer currency documentation.  An optional reference may be included for the transfer. References are useful for identifying transfers intended to pay for items, trades, services and more.
     * Transfer currency
     */
    async transferCurrency(requestParameters: TransferCurrencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.transferCurrencyRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
