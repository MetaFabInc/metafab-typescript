/* tslint:disable */
/* eslint-disable */
/**
 * MetaFab API
 *  Complete MetaFab API references and guides can be found at: https://trymetafab.com
 *
 * The version of the OpenAPI document: 1.1.4
 * Contact: metafabproject@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateExchange200Response,
  CreateExchangeRequest,
  ExchangeOffer,
  GetExchanges200ResponseInner,
  SetExchangeOfferRequest,
  TransactionModel,
  WithdrawFromExchangeRequest,
} from '../models';
import {
    CreateExchange200ResponseFromJSON,
    CreateExchange200ResponseToJSON,
    CreateExchangeRequestFromJSON,
    CreateExchangeRequestToJSON,
    ExchangeOfferFromJSON,
    ExchangeOfferToJSON,
    GetExchanges200ResponseInnerFromJSON,
    GetExchanges200ResponseInnerToJSON,
    SetExchangeOfferRequestFromJSON,
    SetExchangeOfferRequestToJSON,
    TransactionModelFromJSON,
    TransactionModelToJSON,
    WithdrawFromExchangeRequestFromJSON,
    WithdrawFromExchangeRequestToJSON,
} from '../models';

export interface CreateExchangeOperationRequest {
    xAuthorization: string;
    xPassword: string;
    createExchangeRequest: CreateExchangeRequest;
}

export interface GetExchangeOfferRequest {
    exchangeId: string;
    exchangeOfferId: string;
}

export interface GetExchangeOffersRequest {
    exchangeId: string;
}

export interface GetExchangesRequest {
    xGameKey: string;
}

export interface RemoveExchangeOfferRequest {
    exchangeId: string;
    exchangeOfferId: string;
    xAuthorization: string;
    xPassword: string;
}

export interface SetExchangeOfferOperationRequest {
    exchangeId: string;
    xAuthorization: string;
    xPassword: string;
    setExchangeOfferRequest: SetExchangeOfferRequest;
}

export interface UseExchangeOfferRequest {
    exchangeId: string;
    exchangeOfferId: string;
    xAuthorization: string;
    xPassword: string;
}

export interface WithdrawFromExchangeOperationRequest {
    exchangeId: string;
    xAuthorization: string;
    xPassword: string;
    withdrawFromExchangeRequest: WithdrawFromExchangeRequest;
}

/**
 * 
 */
export class ExchangesApi extends runtime.BaseAPI {

    /**
     * Creates a new game exchange and deploys a exchange contract on behalf of the authenticating game\'s primary wallet. The deployed exchange contract allows you to create fixed price rates for players to buy specific items from any item collection or ERC1155 contract. Additionally, an exchange allows you to create exchange offers for some set of item(s) to another set of item(s) or any mix of currency. Exchanges completely supports gasless player transactions.
     * Create exchange
     */
    async createExchangeRaw(requestParameters: CreateExchangeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateExchange200Response>> {
        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling createExchange.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling createExchange.');
        }

        if (requestParameters.createExchangeRequest === null || requestParameters.createExchangeRequest === undefined) {
            throw new runtime.RequiredError('createExchangeRequest','Required parameter requestParameters.createExchangeRequest was null or undefined when calling createExchange.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/exchanges`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateExchangeRequestToJSON(requestParameters.createExchangeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateExchange200ResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new game exchange and deploys a exchange contract on behalf of the authenticating game\'s primary wallet. The deployed exchange contract allows you to create fixed price rates for players to buy specific items from any item collection or ERC1155 contract. Additionally, an exchange allows you to create exchange offers for some set of item(s) to another set of item(s) or any mix of currency. Exchanges completely supports gasless player transactions.
     * Create exchange
     */
    async createExchange(requestParameters: CreateExchangeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateExchange200Response> {
        const response = await this.createExchangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a exchange offer object for the provided exchangeOfferId.
     * Get exchange offer
     */
    async getExchangeOfferRaw(requestParameters: GetExchangeOfferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExchangeOffer>> {
        if (requestParameters.exchangeId === null || requestParameters.exchangeId === undefined) {
            throw new runtime.RequiredError('exchangeId','Required parameter requestParameters.exchangeId was null or undefined when calling getExchangeOffer.');
        }

        if (requestParameters.exchangeOfferId === null || requestParameters.exchangeOfferId === undefined) {
            throw new runtime.RequiredError('exchangeOfferId','Required parameter requestParameters.exchangeOfferId was null or undefined when calling getExchangeOffer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/exchanges/{exchangeId}/items/{exchangeOfferId}`.replace(`{${"exchangeId"}}`, encodeURIComponent(String(requestParameters.exchangeId))).replace(`{${"exchangeOfferId"}}`, encodeURIComponent(String(requestParameters.exchangeOfferId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExchangeOfferFromJSON(jsonValue));
    }

    /**
     * Returns a exchange offer object for the provided exchangeOfferId.
     * Get exchange offer
     */
    async getExchangeOffer(requestParameters: GetExchangeOfferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExchangeOffer> {
        const response = await this.getExchangeOfferRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all exchange offers as an array of exchange offer objects.
     * Get exchange offers
     */
    async getExchangeOffersRaw(requestParameters: GetExchangeOffersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ExchangeOffer>>> {
        if (requestParameters.exchangeId === null || requestParameters.exchangeId === undefined) {
            throw new runtime.RequiredError('exchangeId','Required parameter requestParameters.exchangeId was null or undefined when calling getExchangeOffers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/exchanges/{exchangeId}/offers`.replace(`{${"exchangeId"}}`, encodeURIComponent(String(requestParameters.exchangeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExchangeOfferFromJSON));
    }

    /**
     * Returns all exchange offers as an array of exchange offer objects.
     * Get exchange offers
     */
    async getExchangeOffers(requestParameters: GetExchangeOffersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ExchangeOffer>> {
        const response = await this.getExchangeOffersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of active exchanges for the game associated with the provided `X-Game-Key`.
     * Get exchanges
     */
    async getExchangesRaw(requestParameters: GetExchangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GetExchanges200ResponseInner>>> {
        if (requestParameters.xGameKey === null || requestParameters.xGameKey === undefined) {
            throw new runtime.RequiredError('xGameKey','Required parameter requestParameters.xGameKey was null or undefined when calling getExchanges.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xGameKey !== undefined && requestParameters.xGameKey !== null) {
            headerParameters['X-Game-Key'] = String(requestParameters.xGameKey);
        }

        const response = await this.request({
            path: `/v1/exchanges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetExchanges200ResponseInnerFromJSON));
    }

    /**
     * Returns an array of active exchanges for the game associated with the provided `X-Game-Key`.
     * Get exchanges
     */
    async getExchanges(requestParameters: GetExchangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GetExchanges200ResponseInner>> {
        const response = await this.getExchangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes the provided offerId from the provided exchange. Removed offers can no longer be used.
     * Remove exchange offer
     */
    async removeExchangeOfferRaw(requestParameters: RemoveExchangeOfferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.exchangeId === null || requestParameters.exchangeId === undefined) {
            throw new runtime.RequiredError('exchangeId','Required parameter requestParameters.exchangeId was null or undefined when calling removeExchangeOffer.');
        }

        if (requestParameters.exchangeOfferId === null || requestParameters.exchangeOfferId === undefined) {
            throw new runtime.RequiredError('exchangeOfferId','Required parameter requestParameters.exchangeOfferId was null or undefined when calling removeExchangeOffer.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling removeExchangeOffer.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling removeExchangeOffer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/exchanges/{exchangeId}/offers/{exchangeOfferId}`.replace(`{${"exchangeId"}}`, encodeURIComponent(String(requestParameters.exchangeId))).replace(`{${"exchangeOfferId"}}`, encodeURIComponent(String(requestParameters.exchangeOfferId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Removes the provided offerId from the provided exchange. Removed offers can no longer be used.
     * Remove exchange offer
     */
    async removeExchangeOffer(requestParameters: RemoveExchangeOfferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.removeExchangeOfferRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets a new exchange offer or updates an existing one for the provided id. Exchange offers allow currency to item, item to currency or item to item exchanges.  All request fields besides `id` are optional. Any optional fields omitted will not be used for the offer. This allows you to create many different combinations of offers. For example, you can create an offer that may require 3 unique item ids of specified quantities from a given item collection and gives the user 1 new unique item id in exchange.  Another example, you may want to make an exchange offer from one ERC20 token to another. This is also possible - simple set the input and output currency fields and leave the others blank.
     * Set exchange offer
     */
    async setExchangeOfferRaw(requestParameters: SetExchangeOfferOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.exchangeId === null || requestParameters.exchangeId === undefined) {
            throw new runtime.RequiredError('exchangeId','Required parameter requestParameters.exchangeId was null or undefined when calling setExchangeOffer.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling setExchangeOffer.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling setExchangeOffer.');
        }

        if (requestParameters.setExchangeOfferRequest === null || requestParameters.setExchangeOfferRequest === undefined) {
            throw new runtime.RequiredError('setExchangeOfferRequest','Required parameter requestParameters.setExchangeOfferRequest was null or undefined when calling setExchangeOffer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/exchanges/{exchangeId}/offers`.replace(`{${"exchangeId"}}`, encodeURIComponent(String(requestParameters.exchangeId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetExchangeOfferRequestToJSON(requestParameters.setExchangeOfferRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Sets a new exchange offer or updates an existing one for the provided id. Exchange offers allow currency to item, item to currency or item to item exchanges.  All request fields besides `id` are optional. Any optional fields omitted will not be used for the offer. This allows you to create many different combinations of offers. For example, you can create an offer that may require 3 unique item ids of specified quantities from a given item collection and gives the user 1 new unique item id in exchange.  Another example, you may want to make an exchange offer from one ERC20 token to another. This is also possible - simple set the input and output currency fields and leave the others blank.
     * Set exchange offer
     */
    async setExchangeOffer(requestParameters: SetExchangeOfferOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.setExchangeOfferRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Uses an exchange offer. The required (input) item(s) and/or currency are removed from the wallet or player wallet using the offer. The given (output) item(s) and/or currency are given to the wallet or player wallet using the offer.
     * Use exchange offer
     */
    async useExchangeOfferRaw(requestParameters: UseExchangeOfferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.exchangeId === null || requestParameters.exchangeId === undefined) {
            throw new runtime.RequiredError('exchangeId','Required parameter requestParameters.exchangeId was null or undefined when calling useExchangeOffer.');
        }

        if (requestParameters.exchangeOfferId === null || requestParameters.exchangeOfferId === undefined) {
            throw new runtime.RequiredError('exchangeOfferId','Required parameter requestParameters.exchangeOfferId was null or undefined when calling useExchangeOffer.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling useExchangeOffer.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling useExchangeOffer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/exchanges/{exchangeId}/offers/{exchangeOfferId}/uses`.replace(`{${"exchangeId"}}`, encodeURIComponent(String(requestParameters.exchangeId))).replace(`{${"exchangeOfferId"}}`, encodeURIComponent(String(requestParameters.exchangeOfferId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Uses an exchange offer. The required (input) item(s) and/or currency are removed from the wallet or player wallet using the offer. The given (output) item(s) and/or currency are given to the wallet or player wallet using the offer.
     * Use exchange offer
     */
    async useExchangeOffer(requestParameters: UseExchangeOfferRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.useExchangeOfferRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Withdraws native token, currency or items from a exchange. Whenever an exchange offer has input requirements, the native tokens, currencies or items for the requirements of that offer are deposited into the exchange contract when the offer is used. These can be withdrawn to any other address.
     * Withdraw from exchange
     */
    async withdrawFromExchangeRaw(requestParameters: WithdrawFromExchangeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.exchangeId === null || requestParameters.exchangeId === undefined) {
            throw new runtime.RequiredError('exchangeId','Required parameter requestParameters.exchangeId was null or undefined when calling withdrawFromExchange.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling withdrawFromExchange.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling withdrawFromExchange.');
        }

        if (requestParameters.withdrawFromExchangeRequest === null || requestParameters.withdrawFromExchangeRequest === undefined) {
            throw new runtime.RequiredError('withdrawFromExchangeRequest','Required parameter requestParameters.withdrawFromExchangeRequest was null or undefined when calling withdrawFromExchange.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/exchanges/{exchangeId}/withdrawals`.replace(`{${"exchangeId"}}`, encodeURIComponent(String(requestParameters.exchangeId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WithdrawFromExchangeRequestToJSON(requestParameters.withdrawFromExchangeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Withdraws native token, currency or items from a exchange. Whenever an exchange offer has input requirements, the native tokens, currencies or items for the requirements of that offer are deposited into the exchange contract when the offer is used. These can be withdrawn to any other address.
     * Withdraw from exchange
     */
    async withdrawFromExchange(requestParameters: WithdrawFromExchangeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.withdrawFromExchangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
