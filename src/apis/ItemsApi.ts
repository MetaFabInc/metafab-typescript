/* tslint:disable */
/* eslint-disable */
/**
 * MetaFab API
 *  Complete MetaFab API references and guides can be found at: https://trymetafab.com
 *
 * The version of the OpenAPI document: 1.1.43
 * Contact: metafabproject@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BatchMintCollectionItemsRequest,
  BatchTransferCollectionItemsRequest,
  BurnCollectionItemRequest,
  CreateCollection200Response,
  CreateCollectionItemRequest,
  CreateCollectionRequest,
  GetCollections200ResponseInner,
  GrantCollectionRoleRequest,
  MintCollectionItemRequest,
  RevokeCollectionRoleRequest,
  SetCollectionApprovalRequest,
  SetCollectionItemTimelockRequest,
  TransactionModel,
  TransferCollectionItemRequest,
} from '../models';
import {
    BatchMintCollectionItemsRequestFromJSON,
    BatchMintCollectionItemsRequestToJSON,
    BatchTransferCollectionItemsRequestFromJSON,
    BatchTransferCollectionItemsRequestToJSON,
    BurnCollectionItemRequestFromJSON,
    BurnCollectionItemRequestToJSON,
    CreateCollection200ResponseFromJSON,
    CreateCollection200ResponseToJSON,
    CreateCollectionItemRequestFromJSON,
    CreateCollectionItemRequestToJSON,
    CreateCollectionRequestFromJSON,
    CreateCollectionRequestToJSON,
    GetCollections200ResponseInnerFromJSON,
    GetCollections200ResponseInnerToJSON,
    GrantCollectionRoleRequestFromJSON,
    GrantCollectionRoleRequestToJSON,
    MintCollectionItemRequestFromJSON,
    MintCollectionItemRequestToJSON,
    RevokeCollectionRoleRequestFromJSON,
    RevokeCollectionRoleRequestToJSON,
    SetCollectionApprovalRequestFromJSON,
    SetCollectionApprovalRequestToJSON,
    SetCollectionItemTimelockRequestFromJSON,
    SetCollectionItemTimelockRequestToJSON,
    TransactionModelFromJSON,
    TransactionModelToJSON,
    TransferCollectionItemRequestFromJSON,
    TransferCollectionItemRequestToJSON,
} from '../models';

export interface BatchMintCollectionItemsOperationRequest {
    collectionId: string;
    xAuthorization: string;
    xPassword: string;
    batchMintCollectionItemsRequest: BatchMintCollectionItemsRequest;
}

export interface BatchTransferCollectionItemsOperationRequest {
    collectionId: string;
    xAuthorization: string;
    xPassword: string;
    batchTransferCollectionItemsRequest: BatchTransferCollectionItemsRequest;
}

export interface BurnCollectionItemOperationRequest {
    collectionId: string;
    collectionItemId: number;
    xAuthorization: string;
    xPassword: string;
    burnCollectionItemRequest: BurnCollectionItemRequest;
}

export interface CreateCollectionOperationRequest {
    xAuthorization: string;
    xPassword: string;
    createCollectionRequest: CreateCollectionRequest;
}

export interface CreateCollectionItemOperationRequest {
    collectionId: string;
    xAuthorization: string;
    xPassword: string;
    createCollectionItemRequest: CreateCollectionItemRequest;
}

export interface GetCollectionApprovalRequest {
    collectionId: string;
    operatorAddress: string;
    address?: string;
    walletId?: string;
}

export interface GetCollectionItemRequest {
    collectionId: string;
    collectionItemId: number;
}

export interface GetCollectionItemBalanceRequest {
    collectionId: string;
    collectionItemId: number;
    address?: string;
    walletId?: string;
}

export interface GetCollectionItemBalancesRequest {
    collectionId: string;
    address?: string;
    walletId?: string;
}

export interface GetCollectionItemSuppliesRequest {
    collectionId: string;
}

export interface GetCollectionItemSupplyRequest {
    collectionId: string;
    collectionItemId: number;
    address?: string;
    walletId?: string;
}

export interface GetCollectionItemTimelockRequest {
    collectionId: string;
    collectionItemId: number;
}

export interface GetCollectionItemsRequest {
    collectionId: string;
}

export interface GetCollectionRoleRequest {
    collectionId: string;
    role: string;
    address?: string;
    walletId?: string;
}

export interface GetCollectionsRequest {
    xGameKey: string;
}

export interface GrantCollectionRoleOperationRequest {
    collectionId: string;
    xAuthorization: string;
    xPassword: string;
    grantCollectionRoleRequest: GrantCollectionRoleRequest;
}

export interface MintCollectionItemOperationRequest {
    collectionId: string;
    collectionItemId: number;
    xAuthorization: string;
    xPassword: string;
    mintCollectionItemRequest: MintCollectionItemRequest;
}

export interface RevokeCollectionRoleOperationRequest {
    collectionId: string;
    xAuthorization: string;
    xPassword: string;
    revokeCollectionRoleRequest: RevokeCollectionRoleRequest;
}

export interface SetCollectionApprovalOperationRequest {
    collectionId: string;
    xAuthorization: string;
    xPassword: string;
    setCollectionApprovalRequest: SetCollectionApprovalRequest;
}

export interface SetCollectionItemTimelockOperationRequest {
    collectionId: string;
    collectionItemId: number;
    xAuthorization: string;
    xPassword: string;
    setCollectionItemTimelockRequest: SetCollectionItemTimelockRequest;
}

export interface TransferCollectionItemOperationRequest {
    collectionId: string;
    collectionItemId: number;
    xAuthorization: string;
    xPassword: string;
    transferCollectionItemRequest: TransferCollectionItemRequest;
}

/**
 * 
 */
export class ItemsApi extends runtime.BaseAPI {

    /**
     * Creates (mints) the provided itemIds of the specified quantities to the provided wallet address or wallet address associated with the provided walletId.
     * Batch mint collection items
     */
    async batchMintCollectionItemsRaw(requestParameters: BatchMintCollectionItemsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling batchMintCollectionItems.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling batchMintCollectionItems.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling batchMintCollectionItems.');
        }

        if (requestParameters.batchMintCollectionItemsRequest === null || requestParameters.batchMintCollectionItemsRequest === undefined) {
            throw new runtime.RequiredError('batchMintCollectionItemsRequest','Required parameter requestParameters.batchMintCollectionItemsRequest was null or undefined when calling batchMintCollectionItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/batchMints`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BatchMintCollectionItemsRequestToJSON(requestParameters.batchMintCollectionItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Creates (mints) the provided itemIds of the specified quantities to the provided wallet address or wallet address associated with the provided walletId.
     * Batch mint collection items
     */
    async batchMintCollectionItems(requestParameters: BatchMintCollectionItemsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.batchMintCollectionItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transfers one or multiple items of specified quantities to the provided wallet addresses or wallet addresses associated with the provided walletIds. You may also provide a combination of addresses and walletIds in one request.
     * Batch transfer collection items
     */
    async batchTransferCollectionItemsRaw(requestParameters: BatchTransferCollectionItemsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling batchTransferCollectionItems.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling batchTransferCollectionItems.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling batchTransferCollectionItems.');
        }

        if (requestParameters.batchTransferCollectionItemsRequest === null || requestParameters.batchTransferCollectionItemsRequest === undefined) {
            throw new runtime.RequiredError('batchTransferCollectionItemsRequest','Required parameter requestParameters.batchTransferCollectionItemsRequest was null or undefined when calling batchTransferCollectionItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/batchTransfers`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BatchTransferCollectionItemsRequestToJSON(requestParameters.batchTransferCollectionItemsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Transfers one or multiple items of specified quantities to the provided wallet addresses or wallet addresses associated with the provided walletIds. You may also provide a combination of addresses and walletIds in one request.
     * Batch transfer collection items
     */
    async batchTransferCollectionItems(requestParameters: BatchTransferCollectionItemsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.batchTransferCollectionItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes (burns) the provided quantity of the collectionItemId from the authenticating game or players wallet. The quantity is permanently removed from the circulating supply of the item.
     * Burn collection item
     */
    async burnCollectionItemRaw(requestParameters: BurnCollectionItemOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling burnCollectionItem.');
        }

        if (requestParameters.collectionItemId === null || requestParameters.collectionItemId === undefined) {
            throw new runtime.RequiredError('collectionItemId','Required parameter requestParameters.collectionItemId was null or undefined when calling burnCollectionItem.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling burnCollectionItem.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling burnCollectionItem.');
        }

        if (requestParameters.burnCollectionItemRequest === null || requestParameters.burnCollectionItemRequest === undefined) {
            throw new runtime.RequiredError('burnCollectionItemRequest','Required parameter requestParameters.burnCollectionItemRequest was null or undefined when calling burnCollectionItem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items/{collectionItemId}/burns`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))).replace(`{${"collectionItemId"}}`, encodeURIComponent(String(requestParameters.collectionItemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BurnCollectionItemRequestToJSON(requestParameters.burnCollectionItemRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Removes (burns) the provided quantity of the collectionItemId from the authenticating game or players wallet. The quantity is permanently removed from the circulating supply of the item.
     * Burn collection item
     */
    async burnCollectionItem(requestParameters: BurnCollectionItemOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.burnCollectionItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new game item collection and deploys an extended functionality ERC1155 contract on behalf of the authenticating game\'s primary wallet. The deployed ERC1155 contract is preconfigured to fully support creating unique item types, item transfer timelocks, custom metadata per item, gasless transactions from player managed wallets, and much more.
     * Create collection
     */
    async createCollectionRaw(requestParameters: CreateCollectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCollection200Response>> {
        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling createCollection.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling createCollection.');
        }

        if (requestParameters.createCollectionRequest === null || requestParameters.createCollectionRequest === undefined) {
            throw new runtime.RequiredError('createCollectionRequest','Required parameter requestParameters.createCollectionRequest was null or undefined when calling createCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCollectionRequestToJSON(requestParameters.createCollectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateCollection200ResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new game item collection and deploys an extended functionality ERC1155 contract on behalf of the authenticating game\'s primary wallet. The deployed ERC1155 contract is preconfigured to fully support creating unique item types, item transfer timelocks, custom metadata per item, gasless transactions from player managed wallets, and much more.
     * Create collection
     */
    async createCollection(requestParameters: CreateCollectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCollection200Response> {
        const response = await this.createCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new item type. Item type creation associates all of the relevant item data to a specific itemId. Such as item name, image, description, attributes, any arbitrary data such as 2D or 3D model resolver URLs, and more. It is recommended, but not required, that you create a new item type through this endpoint before minting any quantity of the related itemId.  Any itemId provided will have its existing item type overriden if it already exists.  Item type data is uploaded to, and resolved through IPFS for decentralized persistence.
     * Create collection item
     */
    async createCollectionItemRaw(requestParameters: CreateCollectionItemOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling createCollectionItem.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling createCollectionItem.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling createCollectionItem.');
        }

        if (requestParameters.createCollectionItemRequest === null || requestParameters.createCollectionItemRequest === undefined) {
            throw new runtime.RequiredError('createCollectionItemRequest','Required parameter requestParameters.createCollectionItemRequest was null or undefined when calling createCollectionItem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCollectionItemRequestToJSON(requestParameters.createCollectionItemRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Creates a new item type. Item type creation associates all of the relevant item data to a specific itemId. Such as item name, image, description, attributes, any arbitrary data such as 2D or 3D model resolver URLs, and more. It is recommended, but not required, that you create a new item type through this endpoint before minting any quantity of the related itemId.  Any itemId provided will have its existing item type overriden if it already exists.  Item type data is uploaded to, and resolved through IPFS for decentralized persistence.
     * Create collection item
     */
    async createCollectionItem(requestParameters: CreateCollectionItemOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.createCollectionItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a boolean (true/false) representing if the provided operatorAddress has approval to transfer and burn items from the current collection owned by the address or address associated with the provided walletId.
     * Get collection approval
     */
    async getCollectionApprovalRaw(requestParameters: GetCollectionApprovalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionApproval.');
        }

        if (requestParameters.operatorAddress === null || requestParameters.operatorAddress === undefined) {
            throw new runtime.RequiredError('operatorAddress','Required parameter requestParameters.operatorAddress was null or undefined when calling getCollectionApproval.');
        }

        const queryParameters: any = {};

        if (requestParameters.operatorAddress !== undefined) {
            queryParameters['operatorAddress'] = requestParameters.operatorAddress;
        }

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.walletId !== undefined) {
            queryParameters['walletId'] = requestParameters.walletId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/approvals`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns a boolean (true/false) representing if the provided operatorAddress has approval to transfer and burn items from the current collection owned by the address or address associated with the provided walletId.
     * Get collection approval
     */
    async getCollectionApproval(requestParameters: GetCollectionApprovalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.getCollectionApprovalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a metadata object for the provided collectionItemId.
     * Get collection item
     */
    async getCollectionItemRaw(requestParameters: GetCollectionItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionItem.');
        }

        if (requestParameters.collectionItemId === null || requestParameters.collectionItemId === undefined) {
            throw new runtime.RequiredError('collectionItemId','Required parameter requestParameters.collectionItemId was null or undefined when calling getCollectionItem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items/{collectionItemId}`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))).replace(`{${"collectionItemId"}}`, encodeURIComponent(String(requestParameters.collectionItemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns a metadata object for the provided collectionItemId.
     * Get collection item
     */
    async getCollectionItem(requestParameters: GetCollectionItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getCollectionItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the current collection item balance of the provided collectionItemId for the provided wallet address or the wallet address associated with the provided walletId.
     * Get collection item balance
     */
    async getCollectionItemBalanceRaw(requestParameters: GetCollectionItemBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionItemBalance.');
        }

        if (requestParameters.collectionItemId === null || requestParameters.collectionItemId === undefined) {
            throw new runtime.RequiredError('collectionItemId','Required parameter requestParameters.collectionItemId was null or undefined when calling getCollectionItemBalance.');
        }

        const queryParameters: any = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.walletId !== undefined) {
            queryParameters['walletId'] = requestParameters.walletId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items/{collectionItemId}/balances`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))).replace(`{${"collectionItemId"}}`, encodeURIComponent(String(requestParameters.collectionItemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns the current collection item balance of the provided collectionItemId for the provided wallet address or the wallet address associated with the provided walletId.
     * Get collection item balance
     */
    async getCollectionItemBalance(requestParameters: GetCollectionItemBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.getCollectionItemBalanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the current collection item balances of all collection items for the provided wallet address or the wallet address associated with the provided walletId.
     * Get collection item balances
     */
    async getCollectionItemBalancesRaw(requestParameters: GetCollectionItemBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: number; }>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionItemBalances.');
        }

        const queryParameters: any = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.walletId !== undefined) {
            queryParameters['walletId'] = requestParameters.walletId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/balances`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns the current collection item balances of all collection items for the provided wallet address or the wallet address associated with the provided walletId.
     * Get collection item balances
     */
    async getCollectionItemBalances(requestParameters: GetCollectionItemBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: number; }> {
        const response = await this.getCollectionItemBalancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the currency circulating supply of all collection items.
     * Get collection item supplies
     */
    async getCollectionItemSuppliesRaw(requestParameters: GetCollectionItemSuppliesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: number; }>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionItemSupplies.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/supplies`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns the currency circulating supply of all collection items.
     * Get collection item supplies
     */
    async getCollectionItemSupplies(requestParameters: GetCollectionItemSuppliesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: number; }> {
        const response = await this.getCollectionItemSuppliesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the current circulating supply of the provided collectionItemId.
     * Get collection item supply
     */
    async getCollectionItemSupplyRaw(requestParameters: GetCollectionItemSupplyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionItemSupply.');
        }

        if (requestParameters.collectionItemId === null || requestParameters.collectionItemId === undefined) {
            throw new runtime.RequiredError('collectionItemId','Required parameter requestParameters.collectionItemId was null or undefined when calling getCollectionItemSupply.');
        }

        const queryParameters: any = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.walletId !== undefined) {
            queryParameters['walletId'] = requestParameters.walletId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items/{collectionItemId}/supplies`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))).replace(`{${"collectionItemId"}}`, encodeURIComponent(String(requestParameters.collectionItemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns the current circulating supply of the provided collectionItemId.
     * Get collection item supply
     */
    async getCollectionItemSupply(requestParameters: GetCollectionItemSupplyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.getCollectionItemSupplyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a timestamp (in seconds) for when the provided collectionItemId\'s transfer timelock expires. A value of 0 means the provided collectionItemId does not have a timelock set. Timelocks prevent items of a specific collectionItemId from being transferred until the set timelock timestamp has been surpassed.
     * Get collection item timelock
     */
    async getCollectionItemTimelockRaw(requestParameters: GetCollectionItemTimelockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionItemTimelock.');
        }

        if (requestParameters.collectionItemId === null || requestParameters.collectionItemId === undefined) {
            throw new runtime.RequiredError('collectionItemId','Required parameter requestParameters.collectionItemId was null or undefined when calling getCollectionItemTimelock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items/{collectionItemId}/timelocks`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))).replace(`{${"collectionItemId"}}`, encodeURIComponent(String(requestParameters.collectionItemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns a timestamp (in seconds) for when the provided collectionItemId\'s transfer timelock expires. A value of 0 means the provided collectionItemId does not have a timelock set. Timelocks prevent items of a specific collectionItemId from being transferred until the set timelock timestamp has been surpassed.
     * Get collection item timelock
     */
    async getCollectionItemTimelock(requestParameters: GetCollectionItemTimelockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.getCollectionItemTimelockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all collection items as an array of metadata objects.  Please note that ONLY items that have had at least 1 quantity minted will be returned. If you\'ve created an item that has not been minted yet, it will not be returned in the array response.
     * Get collection items
     */
    async getCollectionItemsRaw(requestParameters: GetCollectionItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionItems.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns all collection items as an array of metadata objects.  Please note that ONLY items that have had at least 1 quantity minted will be returned. If you\'ve created an item that has not been minted yet, it will not be returned in the array response.
     * Get collection items
     */
    async getCollectionItems(requestParameters: GetCollectionItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<object>> {
        const response = await this.getCollectionItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a boolean (true/false) representing if the provided role for this collection has been granted to the provided address or address associated with the provided walletId.
     * Get collection role
     */
    async getCollectionRoleRaw(requestParameters: GetCollectionRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling getCollectionRole.');
        }

        if (requestParameters.role === null || requestParameters.role === undefined) {
            throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling getCollectionRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.role !== undefined) {
            queryParameters['role'] = requestParameters.role;
        }

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.walletId !== undefined) {
            queryParameters['walletId'] = requestParameters.walletId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/collections/{collectionId}/roles`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns a boolean (true/false) representing if the provided role for this collection has been granted to the provided address or address associated with the provided walletId.
     * Get collection role
     */
    async getCollectionRole(requestParameters: GetCollectionRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.getCollectionRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of active item collections for the game associated with the provided `X-Game-Key`.
     * Get collections
     */
    async getCollectionsRaw(requestParameters: GetCollectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GetCollections200ResponseInner>>> {
        if (requestParameters.xGameKey === null || requestParameters.xGameKey === undefined) {
            throw new runtime.RequiredError('xGameKey','Required parameter requestParameters.xGameKey was null or undefined when calling getCollections.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xGameKey !== undefined && requestParameters.xGameKey !== null) {
            headerParameters['X-Game-Key'] = String(requestParameters.xGameKey);
        }

        const response = await this.request({
            path: `/v1/collections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetCollections200ResponseInnerFromJSON));
    }

    /**
     * Returns an array of active item collections for the game associated with the provided `X-Game-Key`.
     * Get collections
     */
    async getCollections(requestParameters: GetCollectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GetCollections200ResponseInner>> {
        const response = await this.getCollectionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Grants the provided role for the collection to the provided address or address associated with the provided walletId. Granted roles give different types of authority on behalf of the collection for specific players, addresses, or contracts to perform different types of permissioned collection operations.
     * Grant collection role
     */
    async grantCollectionRoleRaw(requestParameters: GrantCollectionRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling grantCollectionRole.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling grantCollectionRole.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling grantCollectionRole.');
        }

        if (requestParameters.grantCollectionRoleRequest === null || requestParameters.grantCollectionRoleRequest === undefined) {
            throw new runtime.RequiredError('grantCollectionRoleRequest','Required parameter requestParameters.grantCollectionRoleRequest was null or undefined when calling grantCollectionRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/roles`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GrantCollectionRoleRequestToJSON(requestParameters.grantCollectionRoleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Grants the provided role for the collection to the provided address or address associated with the provided walletId. Granted roles give different types of authority on behalf of the collection for specific players, addresses, or contracts to perform different types of permissioned collection operations.
     * Grant collection role
     */
    async grantCollectionRole(requestParameters: GrantCollectionRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.grantCollectionRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates (mints) the specified quantity of the provided collectionItemId to the provided wallet address or wallet address associated with the provided walletId.
     * Mint collection item
     */
    async mintCollectionItemRaw(requestParameters: MintCollectionItemOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling mintCollectionItem.');
        }

        if (requestParameters.collectionItemId === null || requestParameters.collectionItemId === undefined) {
            throw new runtime.RequiredError('collectionItemId','Required parameter requestParameters.collectionItemId was null or undefined when calling mintCollectionItem.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling mintCollectionItem.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling mintCollectionItem.');
        }

        if (requestParameters.mintCollectionItemRequest === null || requestParameters.mintCollectionItemRequest === undefined) {
            throw new runtime.RequiredError('mintCollectionItemRequest','Required parameter requestParameters.mintCollectionItemRequest was null or undefined when calling mintCollectionItem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items/{collectionItemId}/mints`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))).replace(`{${"collectionItemId"}}`, encodeURIComponent(String(requestParameters.collectionItemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MintCollectionItemRequestToJSON(requestParameters.mintCollectionItemRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Creates (mints) the specified quantity of the provided collectionItemId to the provided wallet address or wallet address associated with the provided walletId.
     * Mint collection item
     */
    async mintCollectionItem(requestParameters: MintCollectionItemOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.mintCollectionItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revokes the provided role for the collection to the provided address or address associated with the provided walletId.
     * Revoke collection role
     */
    async revokeCollectionRoleRaw(requestParameters: RevokeCollectionRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling revokeCollectionRole.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling revokeCollectionRole.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling revokeCollectionRole.');
        }

        if (requestParameters.revokeCollectionRoleRequest === null || requestParameters.revokeCollectionRoleRequest === undefined) {
            throw new runtime.RequiredError('revokeCollectionRoleRequest','Required parameter requestParameters.revokeCollectionRoleRequest was null or undefined when calling revokeCollectionRole.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/roles`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: RevokeCollectionRoleRequestToJSON(requestParameters.revokeCollectionRoleRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Revokes the provided role for the collection to the provided address or address associated with the provided walletId.
     * Revoke collection role
     */
    async revokeCollectionRole(requestParameters: RevokeCollectionRoleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.revokeCollectionRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets approval for the provided address or wallet address associated with the provided walletId to operate on behalf of the authenticating game or player\'s owned items for this collection. Setting an approved value of `true` allows the provided address or address associated with the provided walletId to transfer and burn items from this collection on behalf of the authenticated game or player\'s wallet address.
     * Set collection approval
     */
    async setCollectionApprovalRaw(requestParameters: SetCollectionApprovalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling setCollectionApproval.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling setCollectionApproval.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling setCollectionApproval.');
        }

        if (requestParameters.setCollectionApprovalRequest === null || requestParameters.setCollectionApprovalRequest === undefined) {
            throw new runtime.RequiredError('setCollectionApprovalRequest','Required parameter requestParameters.setCollectionApprovalRequest was null or undefined when calling setCollectionApproval.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/approvals`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetCollectionApprovalRequestToJSON(requestParameters.setCollectionApprovalRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Sets approval for the provided address or wallet address associated with the provided walletId to operate on behalf of the authenticating game or player\'s owned items for this collection. Setting an approved value of `true` allows the provided address or address associated with the provided walletId to transfer and burn items from this collection on behalf of the authenticated game or player\'s wallet address.
     * Set collection approval
     */
    async setCollectionApproval(requestParameters: SetCollectionApprovalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.setCollectionApprovalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the item timelock for the provided collection itemId. The timelock is a unix timestamp (in seconds) that defines a period in time of when an item may be transferred by players. Until the timelock timestamp has passed, the itemId for the given timelock may not be transferred, sold, traded, etc. A timelock of 0 (default) means that there is no timelock set on the itemId and it can be freely transferred, traded, etc.
     * Set collection item timelock
     */
    async setCollectionItemTimelockRaw(requestParameters: SetCollectionItemTimelockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling setCollectionItemTimelock.');
        }

        if (requestParameters.collectionItemId === null || requestParameters.collectionItemId === undefined) {
            throw new runtime.RequiredError('collectionItemId','Required parameter requestParameters.collectionItemId was null or undefined when calling setCollectionItemTimelock.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling setCollectionItemTimelock.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling setCollectionItemTimelock.');
        }

        if (requestParameters.setCollectionItemTimelockRequest === null || requestParameters.setCollectionItemTimelockRequest === undefined) {
            throw new runtime.RequiredError('setCollectionItemTimelockRequest','Required parameter requestParameters.setCollectionItemTimelockRequest was null or undefined when calling setCollectionItemTimelock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items/{collectionItemId}/timelocks`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))).replace(`{${"collectionItemId"}}`, encodeURIComponent(String(requestParameters.collectionItemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetCollectionItemTimelockRequestToJSON(requestParameters.setCollectionItemTimelockRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Sets the item timelock for the provided collection itemId. The timelock is a unix timestamp (in seconds) that defines a period in time of when an item may be transferred by players. Until the timelock timestamp has passed, the itemId for the given timelock may not be transferred, sold, traded, etc. A timelock of 0 (default) means that there is no timelock set on the itemId and it can be freely transferred, traded, etc.
     * Set collection item timelock
     */
    async setCollectionItemTimelock(requestParameters: SetCollectionItemTimelockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.setCollectionItemTimelockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transfers specified quantity of itemId to the provided wallet address or wallet address associated with the provided walletId.
     * Transfer collection item
     */
    async transferCollectionItemRaw(requestParameters: TransferCollectionItemOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionModel>> {
        if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
            throw new runtime.RequiredError('collectionId','Required parameter requestParameters.collectionId was null or undefined when calling transferCollectionItem.');
        }

        if (requestParameters.collectionItemId === null || requestParameters.collectionItemId === undefined) {
            throw new runtime.RequiredError('collectionItemId','Required parameter requestParameters.collectionItemId was null or undefined when calling transferCollectionItem.');
        }

        if (requestParameters.xAuthorization === null || requestParameters.xAuthorization === undefined) {
            throw new runtime.RequiredError('xAuthorization','Required parameter requestParameters.xAuthorization was null or undefined when calling transferCollectionItem.');
        }

        if (requestParameters.xPassword === null || requestParameters.xPassword === undefined) {
            throw new runtime.RequiredError('xPassword','Required parameter requestParameters.xPassword was null or undefined when calling transferCollectionItem.');
        }

        if (requestParameters.transferCollectionItemRequest === null || requestParameters.transferCollectionItemRequest === undefined) {
            throw new runtime.RequiredError('transferCollectionItemRequest','Required parameter requestParameters.transferCollectionItemRequest was null or undefined when calling transferCollectionItem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAuthorization !== undefined && requestParameters.xAuthorization !== null) {
            headerParameters['X-Authorization'] = String(requestParameters.xAuthorization);
        }

        if (requestParameters.xPassword !== undefined && requestParameters.xPassword !== null) {
            headerParameters['X-Password'] = String(requestParameters.xPassword);
        }

        const response = await this.request({
            path: `/v1/collections/{collectionId}/items/{collectionItemId}/transfers`.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters.collectionId))).replace(`{${"collectionItemId"}}`, encodeURIComponent(String(requestParameters.collectionItemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransferCollectionItemRequestToJSON(requestParameters.transferCollectionItemRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionModelFromJSON(jsonValue));
    }

    /**
     * Transfers specified quantity of itemId to the provided wallet address or wallet address associated with the provided walletId.
     * Transfer collection item
     */
    async transferCollectionItem(requestParameters: TransferCollectionItemOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionModel> {
        const response = await this.transferCollectionItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
